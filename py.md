---
title: Конспект Python
date: '2023-07-28'
tags: ['python']
draft: false
summary: 
images: []
---

<TOCInline toc={props.toc} asDisclosure />

## Теория

- Любая  сущность - объект определенного класса
- У каждого объекта есть атрибуты
- Атрибут объекта называется методом, если его значение - функция
- Один класс может порождать множество объектов
- Объекты наследуют методы своего класса
- Объект - экземпляр класса
- Класс - это прототип для создания объектов
- Функция - программа выполняющая какое-то одно действие, можно вызвать в другой части программы

## Типы данных

| Тип | Описание | Пример |
|:-----------|:--|:--|
|`str`|Строка|`‘String’`|
|`int`|Целое число|`10 -4 0`|
|`bool`|Логика|`true/false`|
|`list`|Список|`[1, 2, 3]`|
|`dict`|Словарь|`{‘min’: 5, ‘max’: 8}`|
|`tuple`|Кортеж|`(a, b)`|
|`set`|Набор (множество)|`{a, b}`|
|`range`|Диапазон||

## Числа

int - целые числа
float - с десятичной точкой
complex - комплексные числа
namedtuple - именованный картеж

one_million = 1_000_000

конвертация из float в int
average_price = 28.75
price = int(average_price)

print(price) # 28
print(type(price)) # <class ‘int’>

конвертация из str во float
average_price = ‘28.75’
price = float(average_price)

print(price) # 28.75
print(type(price)) # <class ‘float’>

## Строки

Строка - последовательность символов
‘JoJo’ - одно слово
“JoJo's Bizarre Adventure” - многово
“””JoJo's Bizarre Adventure
Невероятные приключения ДжоДжо””” - многострочный

print(len(string)) - вернет длину строки
print(string[0]) - вернет первый символ строки
print(string[3:6]) - вернет диапазон символов, не включает последнее значение

Ввод input всегда строка

| Имя | Описание | Комментарий |
|:-----------|:--|:--|
|startswith(prefix, start, end)|возвращает True, если строка начинается c prefix|prefix обязательный|
|endswith(suffix, start, end)|возвращает True, если строка оканчивается на suffix|suffix обязательный|
|pow(base, power)|возводит base в степень power||
|round(number, digits)|округляет значение в сторону ближайшего числа|digits опционально, указывает количество символов после запятой|

Соединение строк

‘Hello ‘ + ‘python’ - соединение через +

```
hello = ‘Hello’
world = ‘world’
greeting = hello + ‘ ‘ + world # соединение через переменные, нужна конвертация в str
```

```
hello = ‘Hello’
world = ‘world’
greeting = f”{hello} {world}” # соединение через f-strings. Можно использовать значения разных типов без явной конвертации
```

## Списки (list) []

Упорядоченная последовательность элементов. Изменяемый объект

my_list = [1, 2, 3]
print(my_list[0]) - первый элемент списка
print(my_list[-1]) - последний элемент списка
my_list[2] = 5 - заменит 3 объект списка на 5.
del my_list[2] - удалит третий символ
my_list = old_list[:] - копирует список в новую переменную

Методы списков

| Имя | Описание | Комментарий |
|:-----------|:--|:--|
|append()|добавляет элемент в конце списка||
|pop(index)|удаляет элемент списака|index не обязательное, по умолчанию -1, удаленный элемент можно сохранить в переменную|
|remove|удаляет объект списка||
|insert(pos, val)|добавляет элемент val перед индексом pos||
|sort(reverse=True)|сортирует элементы списка|reverse - не обязательно, указывает порядок|
|index(val, start, end)|ищет позицию элемента списка|start, end - не обязательно|
|clear()|очищает список||
|copy(list)|копирует лист в новую переменную||
|extend|добавляет итерируемый элемент в конце списка||
|reverse|обращает порядок элементов списка||
|count(val)|считает количество элементов val в списке||

Функции списков

| Имя | Описание | Комментарий |
|:-----------|:--|:--|
|min()| минимальное значение списка
|max()|максимальное значение списка|
|sum()|сумма значений списка|
|len()|длина списка|

## Словари {‘dict’: ‘dict’04}

Словарь - набор элементов КЛЮЧ: ЗНАЧЕНИЕ
Ключи уникальны
Порядок элементов не имеет значения, нет индекса
Ключи словарей не их атрибуты
Словари можно формировать из значений переменных или функций

print(my_dict[‘key’]) - получим значение ключа в словаре
my_dict[‘key’] = True - добавляет новый ключ или меняет существующий
del my_dict[‘key’] - удалит ключ из словаря
print(my_dict[‘key_out_dict’][‘key_in_dict’])

Методы

| Имя | Описание | Комментарий |
|:-----------|:--|:--|
|get(‘key’, error)| получаем значение из словаря избегая ошибки ключа|вернет значение error если key нет в словаре|
|items()|возвращается список пар ключ-значения, каждая пара - кортеж|вывод класса dict_items|
|keys()|возвращает названия ключей словаря|вывод класса - dict_keys|
|popitem()|удалит последний ключ|не использовать|
|del()|удалит значение||
|clear()| очищает словарь||
|copy()|создаст новый словарь из существующего||

## Кортеж (tuple)

Упорядоченная последовательность элементов
Изменять нельзя
Можно изменить список или словарь внутри кортежа
Можно объединить два кортежа с помощью +
Для изменения кортеж можно конвертировать в список. После изменения список - в кортеж

Методы

| Имя | Описание | Комментарий |
|:-----------|:--|:--|
|count(val)|можно посчитать количество элементов||
|index(val)|можно узнать индекс первого элемента||

## Наборы {set}

Неупорядоченная последовательность элементов, только уникальные элементы
Изменяемые
Нельзя хранить изменяемые объекты. Для каждого элемента в наборе хранится хэш и он не изменяется пока элемент сохраняется в наборе
В наборах обычно хранят однотипные данные

Методы наборов

| Имя | Описание | Комментарий |
|:-----------|:--|:--|
|add()|добавить элемент в набор||
|union|объединит наборы удалив дубли|’|’|
|remove|удалит элемент множества, может вернуть ошибку||
|a.difference(b)|вернет элементы a, которых нет в b||
|a.symmetric_difference(b)|вернет элементы уникальные для каждого набора||
|intersection()|возвращает пересечение двух наборов|’&’|
|discard|удалит элемент множества, вернет None||
|clear|очищает множество, ничего не возвращает||
|copy|копирует в новый набор||
|update|добавляет итерируемые объекты в набор||
|b.issubset(a)|проверит, включен ли набор b в набор a, вернет bool||
|a.issuperset(b)|проверит, включен ли набор b в набор a, вернет bool||
|pop|возвращает случайный элемент удалив из множества||

## Диапазон (range)

Упорядоченная неизменяемая последовательность элементов
Используются в циклах

range(start, stop, step)

Методы

| Имя | Описание | Комментарий |
|:-----------|:--|:--|
|index(a)|вернет индекс элемента а, если нет - вернет ошибку||
|count(a)|количество вхождений в диапазон, 1 или 0||

## Конвертация типов

python не выполняет неявную конвертацию типов

Встроенные функции для явной конвертции типов:

типДанных()

srt() float() tuple() int() list() set()

print(int_num.__mul__(float_num))
print(float_num.__rmul__(int_num))

| Имя | измениемый | индексируемый | уникальные элементы |
|:-----------|:--|:--|:--|
|Список [list]|изменяемый|индексированный|дублирующиеся|
|Кортеж (tuple)|неизменяемый|индексированный|дублирующиеся|
|Набор {set}|изменяемый|неиндексированный|уникальные|
|Словарь {‘a’: b}|изменяемый|неиндексированный|уникальные|
|Диапазон|неизменяемый|индексированный|уникальные|
|Строка|неизменяемый|индексированный|дублирующиеся|

## Функции

Блок кода, который можно выполнять многократно
Функция - экземпляр класса function
Функция возвращает None, если нет return
Функцию нужно вызвать для выполнения
Ключевое слово `pass` можно использовать вместо тела функции
Не рекомендуется внутри функции изменять внешнии переменные
Используй copy/deepcopy при передаче функции изменяемого объекта
Колбэк функции - вызов одной функции другой функцией, принявшей название вызываемой функции как аргумент. Нужно для отделения разных частей кода.
-Называть функции исходя из выполняемых задач
-Название функции начинать с глагола
-Одна функция должна выполнять одну задачу
-Не рекомендуется изменять внешние относительно функции переменные

Документация функции (docstring) “”” docstring“””

global a
a = 11 - создание глобальной переменной а в функции

print(dir()) - покажет переменные в текущей области видимости

#### Аргументы функции

| Имя | Описание | Комментарий |
|:-----------|:--|:--|
|позиционные аргументы|def my_func(name, age):...
my_func(name, age)|важен порядок|
|аргументы в tuple|def my_func(*arg):
my_func(a, b, c, d)|объединяет в кортеж|
|аргументы в dict|def my_func(**arg)
my_func(name=’a’, age=2)||
|с ключевыми словами|def my_func(name, age):...
my_func(name=’a’, age=2)|не важен порядок, читабельнее|
|с дефолтными параметрами|def my_func(name, age=1):...
my_func(name=’a’)|можно вызывать без дефолтного аргумента, может быть функцией|

#### Лямбда функция

Лямбда функции всегда анонимны, без имени.

lambda parameters: expression

#### Встроенные функции

| Имя | Описание | Комментарий |
|:-----------|:--|:--|
|print()|выводит значение на экран|print(“строка строка”)|
|input()|ввести данные в терминале|name = input(“y nam: “)|
|dir()|название всех методов объекта (значение метода функция)|print(dir(“string”))|
|upper()|переводит значение строки в верхний регистр|print(name.upper())|
|lower()|переводит значение строки в нижний регистр||
|capitalize()|заменяет первую букву строки на заглавную||
|split(разделитель)|разобьет строку по разделителю||
|casefold()|более агрессивный lower()||
|center(length,split)|выставляет строку по центру добавляя символы слева и справа|length обязательный|
|count(value, start, end)|ищет value в строке|value - обязательный|
|endswith(suf, start, end)|возвращает true, если строка заканчивается suf|suf - постфикс, обязательный|
|expandtabs(tabsize)|меняет табуляцию на пробелы|tabsize - максимальное количество пробелов|
|find(value, start, end)|ищет первое вхождение в строку|value - значение, обязательно. Если значения нет вернет -1|
|index(value, start, end)|ищут первое вхождение в строку|value - значение, обязательно. Если значения нет вернет ошибку|
|zfill(length)|заполняет строку нулями с начала|length - длина строки, обязательный|
|id(my_var)|возвращает ссылку на объект в памяти||
|type(my_var)|выводит класс экземпляра объекта||
|len(string)|возвращает длину строки||
|replace(old, new, count)|заменяет в строке значение old на new count раз|old, new обязательные|
|isinstance(var, class)|проверяет, являет ли переменная var объектом класса class||
|hex()|представление в hex виде||

#### zip функция

Функция соединяет две последовательности.
Если количество элементов разное - лишнии отбрасываются
При конвертации в list вернет список кортежей
При конвертации в dict требуется соединять две последовательности
Если требуется порядок объединять нужно индексируемые элементы

## Магические методы

Магические методы - внутренние методы класса, обычно не вызываются явно

print(help(my_list.__eq__))

## Инструкции

Инструкция выполняет действие

--присвоение значения
my_name = ‘kitb’

--условная инструкция
if my_name:
 print(my_name)

--импортирование модуля
import datetime

|return|возвращает значение функции, которое можно использовать далее в программе. return прекращает выполнение функции|

## Выражения

Результатом выражения является значение

5 + 3 #8 - результат выражения - значение

my_func(10, 5) # результат функции - значение

чтобы использовать результат функции нужно передать его переменной или другой функции

## Переменные

Правила работы:
Выбирать осмысленные название
Использовать существительные для переменных, например name, comment, new_photos
Использовать глаглы для функций и методов, например get_data, create_request, merge_names

Типы именования

snake_case - переменных, функций, методов, модулей
PascalCase - классов
my-package - пакетов
DB_PASSWORD - констант

Объявление и присвоение происходит одновременно my_name = ‘kitb’
Тип переменной определяется типом присвоенного значения
Переменная содержит ссылку на объект
Есть Mutable(изменяемые, list, dictionary, set, пользовательские классы) и Immutable(неизменяемые, str, bool, int, float, tuple, NoneType, range) объекты

## Операторы

Инфиксная запись - когда оператор между операндами
Приоритетность операторов - используй круглые скобки
in/not in - проверяет присутствие элемента в последовательности, вернет bool
is/is not - проверяет совпадают ли объекты в памяти, в отличие от == !=, проверяющих совпадение элементов
not not - оператор, равносильный bool
Значение, которое при приведении к логическому типу дает False является ложным
При использовании if происходит конвертация значения в bool, можно не писать условия для ложных значений

| Имя | Описание | Комментарий |
|:-----------|:--|:--|
|ложные значения|int 0, float 0.0, complex 0j, bool False, NoneType None, dict {}, list[], tuple(), set set{}, range range(0), str “”|
|арифметические| + - * /|
|сравнения| == != < >|
|логические|not and or is is not in not in|
|присвоения| = |

Унарные операторы один операнд

- my_num

- my_num - конвертирует в число
not my_num - отрицание правдивого значения - False

Бинарные операторы два операнда

a = 5 - присвоение
a + b - сложение
a += 5 - увеличение и присвоение
a == b - сравнение
a and b

## Логические операторы

not - возвращает bool. Чаще все используется в IF.
Отрицаем ложно - получаем True, отрицаем правдивое - False (not 10 - False, not ‘’ - True)
Отрицание отрицания (not not) проверит ложность значение (not not 10 - True, not not ‘’ - False)

and, or - возвращает значение операнда. Операторы короткого замыкания

выражение_1 and выражение_2
Если выражение_1 ложно - вернет выражение_1. Если истинно - выражение_2
выражение_1 or выражение_2
Если выражение_1 истинно, то вернет выражение_1. Если ложно - вернет выражение_2

** - оператор распаковки словаря
| - оператор объединения словарей, порядок важен

dict_merge = dict_one | dict_two

## Копирование

После копирования изменяемый объектов изменения отражаются на всех копиях

| Имя | Описание | Комментарий |
|:-----------|:--|:--|
|copy()|копирование изменяемой переменной в новую|не работает для вложенных изменяемых объектов|
|deepcopy|метод для глубокого копирования объекта|из библиотеки copy|

## Обработка ошибок

Обработка ошибки происходит в конструкции try/except
Exception - родительский класс для ошибок

```
try: # обрабатываемый код
    print('10' / 0)
except ZeroDivisionError as e: # ошибка 1
    print(e)
except TypeError as e: # ошибка 2
    print(e)
else: # если ошибок не возникло
    print("There was no error")
finally: # в любом случае выполняется
    print('Continue...')
```

Создание ошибки в функции с помощью raise
def divide_nums(a, b):
if b == 0:
raise TypeError("Second argument can't be 0")
return a / b

Распаковка

Извлечение значений и присвоение их переменным

my_list = [1, 2, 3]
one, two, three = my_list # распаковка списка или кортежа

my_list = [1, 2, 3]
one, *remaining_nums = my_list #передали первый элемент в переменную и остальные собрали в новый список или кортеж

распаковка словаря

```
print(user_info(**user_profile)) # распаковка словаря
print(user_info(user_profile['name'], user_profile['comments_qty'])) # выбор по ключам
print(user_info(name=user_profile['name'], comments_qty=user_profile['comments_qty'])) # через именованные переменные
```

распаковка списка или кортежа

```
print(user_info(*user_profile))
print(user_info(user_profile[0], user_profile[1]))
print(user_info(name=user_profile[0], comments_qty=user_profile[1]))
```

## vscode hotkeys

| hotkeys | description |
|:-----------|:--|
|ctrl+alt+n|code runner запуск кода|
|ctrl+shift+space|подсказка|
|ctrl+,|настройки|
|ctrl+j|скрыть панель выполнения|
|ctrl+shift+k|удалит строку|
|ctrl+d|выбрать текущее слово|
|shift+c+v|скопировать выделенную строку|
|ctrl+/|закомментировать/раскомментировать выделенный фрагмент|
|ctrl+shift+p > format document with > python (pep8)|отформатирует код по pep8|

## Примеры

выведет список встроенных в python функций

```
print(dir(__builtins__)
```

Input в int

```
any_num = int(input("Enter any number: "))
print(any_num)
print(type(any_num))
```

Достпу к элементу словаря внутри списка

```
users = [
{
'user_id': 134,
'user_name': 'Alice'
},
{
'user_id': 342,
'user_name': 'kitb'
}
]


print(len(users))
print(users[1]['user_id'])
```

Перебор индексов кортежа по одинаковым значениям

```
my_nums = (10, 14, 14, 45, 44, 45, 45)


index_one = my_nums.index(45)
index_two = my_nums.index(45, index_one + 1)
index_three = my_nums.index(45, index_two + 1)


print(index_one, index_two, index_three)
```

Вернет уникальные для каждого набора элементы

```
a = {'abc', 'd', 'f', 'y'}
b = {'abc', 'd', 'f', 'l'}


print((a | b) - (a & b))
```

Использование диапазонва с if

```
my_range = range(5)


for n in my_range:
    print(n)
```

использовние картежа для множества аргументов

```
def sum_nums(*args):
    print(args)
    print(type(args))
    print(args[0])
    return sum(args)

print(sum_nums(2, 66, 5, 53, 6))
```

Пример использования колбэк функции

```
def print_number_info(num):
    if (num % 2) == 0:
        print("Entered number is even")
    else:
        print("Entered number is odd")


def print_square_num(num):
    print("Square of the num is", num * num)


def process_number(num, callback_fn):
    callback_fn(num)

entered_num = int(input('Enter any number: '))

process_number(entered_num, print_number_info)
process_number(entered_num, print_square_num)
```

Пример использования лямбда функции

```
def greeting(greet):
    return lambda name: f"{greet}, {name}!"




morning_greeting = greeting("Good Morning") # Good Morning, kitb!
print(morning_greeting('kitb'))


evening_greeting = greeting("Good Evening") # Good Evening, kitb!
print(evening_greeting('kitb'))
```

Распаковка словаря

```
button = {
'width': 200,
'text': 'Buy',
}


red_button = {
**button, # распаковка словаря
'color': 'red',
}


print(red_button) # {'width': 200, 'text': 'Buy', 'color': 'red'}
print(button) # {'width': 200, 'text': 'Buy'}
```

Распаковка словаря в именованные переменные

```
user_profile = {
'name': 'kitb',
'comments_qty': 23,
}




def user_info(name, comments_qty=0):
    if not comments_qty:
        return f"{name} has no comments"
    return f"{name} has {comments_qty} comments"




print(user_info(**user_profile))
```

Обработка ошибкок

```
def image_info(my_dict):
    if ('image_title' not in my_dict) or ('image_id' not in my_dict):
        raise TypeError("словарь должен содержать image_title и image_id")
    return print(f"image '{my_dict['image_title']}' has id {my_dict['image_id']}")




dict_one = {'image_id': 1255, 'image_title': 'kotek'}
dict_two = {'image_title': 'kotek', 'image_size': 500}
dict_three = {'one': 1, 'two': 2}


try:
    image_info(dict_one)
except Exception as e:
    print(e)


try:
    image_info(dict_two)
except Exception as e:
    print(e)


try:
    image_info(dict_three)
except Exception as e:
    print(e)
```
